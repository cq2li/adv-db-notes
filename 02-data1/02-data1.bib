@misc{zeng2023empirical,
      title={An Empirical Evaluation of Columnar Storage Formats}, 
      author={Xinyu Zeng and Yulong Hui and Jiahong Shen and Andrew Pavlo and Wes McKinney and Huanchen Zhang},
      year={2023},
      eprint={2304.05028},
      archivePrefix={arXiv},
      primaryClass={cs.DB}
}

@inproceedings{10.1145/1376616.1376712,
author = {Abadi, Daniel J. and Madden, Samuel R. and Hachem, Nabil},
title = {Column-stores vs. row-stores: how different are they really?},
year = {2008},
isbn = {9781605581026},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/1376616.1376712},
doi = {10.1145/1376616.1376712},
abstract = {There has been a significant amount of excitement and recent work on column-oriented database systems ("column-stores"). These database systems have been shown to perform more than an order of magnitude better than traditional row-oriented database systems ("row-stores") on analytical workloads such as those found in data warehouses, decision support, and business intelligence applications. The elevator pitch behind this performance difference is straightforward: column-stores are more I/O efficient for read-only queries since they only have to read from disk (or from memory) those attributes accessed by a query.This simplistic view leads to the assumption that one can obtain the performance benefits of a column-store using a row-store: either by vertically partitioning the schema, or by indexing every column so that columns can be accessed independently. In this paper, we demonstrate that this assumption is false. We compare the performance of a commercial row-store under a variety of different configurations with a column-store and show that the row-store performance is significantly slower on a recently proposed data warehouse benchmark. We then analyze the performance difference and show that there are some important differences between the two systems at the query executor level (in addition to the obvious differences at the storage layer level). Using the column-store, we then tease apart these differences, demonstrating the impact on performance of a variety of column-oriented query execution techniques, including vectorized query processing, compression, and a new join algorithm we introduce in this paper. We conclude that while it is not impossible for a row-store to achieve some of the performance advantages of a column-store, changes must be made to both the storage layer and the query executor to fully obtain the benefits of a column-oriented approach.},
booktitle = {Proceedings of the 2008 ACM SIGMOD International Conference on Management of Data},
pages = {967–980},
numpages = {14},
keywords = {c-store, column-oriented dbms, column-store, compression, invisible join, tuple materialization, tuple reconstruction},
location = {Vancouver, Canada},
series = {SIGMOD '08}
}

@article{Dremel,
author = {Melnik, Sergey and Gubarev, Andrey and Long, Jing Jing and Romer, Geoffrey and Shivakumar, Shiva and Tolton, Matt and Vassilakis, Theo},
title = {Dremel: interactive analysis of web-scale datasets},
year = {2010},
issue_date = {September 2010},
publisher = {VLDB Endowment},
volume = {3},
number = {1–2},
issn = {2150-8097},
url = {https://doi.org/10.14778/1920841.1920886},
doi = {10.14778/1920841.1920886},
abstract = {Dremel is a scalable, interactive ad-hoc query system for analysis of read-only nested data. By combining multi-level execution trees and columnar data layout, it is capable of running aggregation queries over trillion-row tables in seconds. The system scales to thousands of CPUs and petabytes of data, and has thousands of users at Google. In this paper, we describe the architecture and implementation of Dremel, and explain how it complements MapReduce-based computing. We present a novel columnar storage representation for nested records and discuss experiments on few-thousand node instances of the system.},
journal = {Proc. VLDB Endow.},
month = {sep},
pages = {330–339},
numpages = {10}
}
