# Optimizer Generators

1. Exodus, Volcano, Cascades

2. Separate the search strategy of an optimizer from the data model. Separate the transformation rules and logical operators from physical rules and physical operators.

%% ==================================================================


# Predicate Push-down Optimization

1. Approach #1: Logical Transformation Rule
    + Predicate push-down is a logical transformation rule like any other in Cascades.
    + This creates an exponential # of equivalent operator trees.
    + Can use the cost-model to determine the benefit of a push-down.
   
2. Approach #2: Rewrite Phase
    + Perform the push-down *before* starting the Cascades search as an initial rewrite phase.
    + More efficient to execute, but is disconnected from the cost model and thus may be tricky to support complex predicate.

3. Approach #3: Late Binding
    + Perform the push-down *after* generating the optimal plan in Cascades.
    + Will likely produce a bad plan because the Cascades search does not consider predicates (i.e., the selectivity of every operation is '1').
    

1. First extract the predicates from the query split on conjunctions. 
    + Group them based on what tables they reference. Predicates that reference more than one table are stored in a separate group for that set of tables.

2. The optimizer then needs to difure out whether to place these predicates in the query's logical plan.

%% ==================================================================

# Nested Queries

1. Five types of nested queries
