\documentclass[11pt]{article}

\newcommand{\lecturenumber}{12}
\newcommand{\lecturename}{Logging Protocols}
\newcommand{\lecturedata}{2018-02-26}

\usepackage{../dbnotes}

\begin{document}

\maketitle
\thispagestyle{plain}

\section{Logging and Recovery}
\begin{itemize}
    \item Recovery algorithms are techniques to ensure database \textbf{consistency}, txn \textbf{atomacity}, and \textbf{durability} despite failures
    \item Recovery Algorithms have two parts
    \begin{enumerate}
        \item Actions during normal txn processing to ensure that the DBMS can recover from a failure
        \item Actions after a failure to recover the database to a state that ensures atomicity, consistency, and durability
    \end{enumerate}
\end{itemize}

    \subsection*{Logging Schemes}

    \subsubsection*{Physical Logging}
    \begin{itemize}
        \item Record the changes made to a specific record in the database
        \item Example: Store the original value and the after value for an attribute that is changed by a query
    \end{itemize}

    \subsubsection*{Logical Logging}
    \begin{itemize}
        \item Record the high-level operations executed by txns
        \item Example: The \sql{UPDATE}, \sql{DELETE} and \sql{INSERT} queries invoked by a txn
    \end{itemize}

    \subsubsection*{Logical vs Physical Logging}
    \begin{itemize}
        \item Logical logging writes less data in each log record than physical logging
        \item Difficult to implement recovery with logical logging if you have concurrent txnss
        \item Its hard to determine which parts of the database may have been modified by a query before crash and it takes longer to recover because you have to re-execute every txn over again
    \end{itemize}

\section{Disk-Oriented Logging and Recovery}
\begin{itemize}
    \item The "gold standard" for physical logging and recovery ina  disk-oriented DBMS is \textbf{ARIES} ~\cite{p94-mohan}
    \item ARIES: Algorithms for Recovery and Isolation Exploiting Semantics
    \item Invented by IBM Research in the early 1990s
    \item Relies on STEAL and NO-FORCE buffer pool management policies
\end{itemize}

    \subsection*{ARIES Main Ideas}
    \begin{itemize}
        \item \textbf{Write-Ahead Logging}
        \begin{itemize}
            \item Any change is recorded in log on stable storage before the database change is written to disk
            \item Each log record is assigned a unique identifier (LSN)
        \end{itemize}
        \item \textbf{Repeating History During Redo}
        \begin{itemize}
            \item On restart, retrace actions and restore database to exact state before crash
        \end{itemize}
        \item Logging Changes During Undo
        \begin{itemize}
            \item Record undo actions to log to ensure action is not repeated in the event of repeated failures
        \end{itemize}
    \end{itemize}

    \subsection*{ARIES Recovery Phases}
        \subsubsection*{Phase 1: Analysis}
        \begin{itemize}
            \item Read the WAL to identify dirty pages in the buffer pool and active txns at the time of the crash
        \end{itemize}
        \subsubsection*{Phase 2: Redo}
        \begin{itemize}
            \item Repeat all actions starting from an approprite point in the log
            \item Log redo teps in case of crash during recovery
        \end{itemize}
        \subsubsection*{Phase 3: Undo}
        \begin{itemize}
            \item Reverse the actions of txns that did not commit before the crash
        \end{itemize}

    \subsection*{Log Sequence Numbers}
    \begin{itemize}
        \item Every log record has a globally unique \textbf{log sequence numbers} (LSN) that is used to determine the serial order of those records
        \item The DBMS keeps track of various LSNs in both volatile and non-volatile storage to determine the order of almost \textbf{everything}
    \end{itemize}

    \subsection*{Optimizations}
    \begin{itemize}
        \item Group Commit
        \begin{itemize}
            \item Batch together log records from multiple txns and flush them together with a single \textbf{fsync}
            \item Logs are flushed either after a timeout or when the buffer gets full
            \item Originally developed in \dbSys{IBM IMS Fastpath} in the 1980s
            \item Amortizes the cost of I/O over several transactions
        \end{itemize}
        \item Early Lock Release
        \begin{itemize}
            \item A txn's locks can be released before its commit record is written to disk as long as it does not return results to the client before becoming durable
            \item Other txns can read data updated by a \textbf{pre-committed} txn become dependent on it and also have to wait for their predecessor's log records to reach disk
        \end{itemize}
    \end{itemize}

\section{In-Memory Database Recovery}
\begin{itemize}
    \item Recovery is slightly easier because the DBMS does not have to worry about tracking dirty pages in case of a crash during recovery
    \item An in-memory DBMS also does not need to store undo records
    \item The DBMS is still stymied by the slow sync time of non-volatile storage
    \item The early papers (1980s) on recovery for in-memory DBMSs assume that there is non-volatile memory ~\cite{p104-lehman}
\end{itemize}


\section{SiloR ~\cite{zheng-osdi14}}
    \begin{itemize}
        \item SiloR uses the epoch based OCC that we discussed previously
        \item It achieves high performance by parallelizing all aspects of logging, checkpointing, and recovery
    \end{itemize}

    \subsection*{Logging Protocol}
    \begin{itemize}
        \item The DBMS assumes that there is one storage device per CPU socket
        \item Assigns one logger thread per device
        \item Worker threads are grouped per CPU socket
        \item As the worker executes a txn, it creates new log records that contain the values that were written to the database (i.e. REDO)
        \item Each logger thread maintains a pool of log buffers that are given to its worker threads
        \item When a worker's buffer is full, it gives it back to the logger thread to flush to disk and attempts to acquire a new one
        \item If there are no available buffers, then it stalls
    \end{itemize}

    \subsection*{Log Files}
    \begin{itemize}
        \item The logger threads write buffers out to files
        \begin{itemize}
            \item After 100 epochs, it creates a new file
            \item The old file is renamed with a marker indicating the max epoch of records that it contains
        \end{itemize}
        \item Log Record Format
        \begin{itemize}
            \item Id of the txn that modified the record (TID)
            \item A set of value log triples (Table, Key, Value)
            \item The value can be a list of attribute + value pairs
        \end{itemize}
    \end{itemize}

    \subsection*{Persistent Epoch}
    \begin{itemize}
        \item A special logger thread keeps track of the current persistent epoch (\textbf{pepoch})
        \item Special log file that maintains the high epoch that is durable across all the loggers
        \item Trxns that executed in epoch \textbf{$e$} can only release their results when the \textbf{pepoch} is durable to non-volatile storage
    \end{itemize}

    \subsection*{Recovery Protocol}
    \begin{itemize}
        \item Phase 1: Load Last Checkpoint
        \begin{itemize}
            \item Install the contents of the last checkpoint that was saved into the database
            \item All indexes have to be rebuilt
        \end{itemize}
        \item Phase 2: Replay Log
        \begin{itemize}
            \item Process logs in reverse order to reconcile the latest version of each tuple
        \end{itemize}
        \item First Check the \textbf{pepoch} file to determine the most recent persistent epoch
        \item Any log record from after the \textbf{pepoch} is ignored
        \item Log files are processed from newest to oldest
        \begin{itemize}
            \item Value logging is able to be replayed in any order
            \item For each log record, the thread checks to see whether the tuple already exists
            \item If it does not, then it is created with the value
            \item If it does, then the tuple's value is overwritten only if the log TID is newer than the tuple's TID
        \end{itemize}
    \end{itemize}

\section{\dbSys{VoltDB}}
    \subsection{Command Logging ~\cite{malviya-icde14}}
    \begin{itemize}
        \item Logical logging scheme where the DBMS only records the stored procedure invocation
            \begin{itemize}
                \item Store procedure name
                \item Input parameters
                \item Additional safety checks
            \end{itemize}
        \item Issue: If the log contains multi-node txns, then if one node goes down, and there are no more replicas, then the entire DBMS has to restart
    \end{itemize}

    \subsection*{Deterministic Concurrency Control}
    \begin{itemize}
        \item For a given state of the database, the execution of a serial schedule will always put the database in the same new state if the order of txns is defined before they start executing and the txn logic is deterministic
    \end{itemize}

    \subsection*{Logging Protocol}
    \begin{itemize}
        \item The DBMS logs the txn command \textbf{before} it starts executing once a txn has been assigned its serial order
        \item The node with the txn's base partition is responsible for writing the log record
        \begin{itemize}
            \item Remote partitions do not log anything
            \item Replica nodes have to log just like their master
        \end{itemize}
    \end{itemize}


    \subsection*{Recovery Protocol}
    \begin{itemize}
        \item The DBMS loads in the last complete checkpoint from disk
        \item Nodes then re-execute all of the txns in the log that arrived after the checkpoint started
        \begin{itemize}
            \item The amount of time elapsed since the last checkpoint in the log determines how long recovery will take
            \item Txns that are aborted first still have to be executed
        \end{itemize}
    \end{itemize}

    \subsection*{Replication}
    \begin{itemize}
        \item Executng a deterministic txn on the multiple copies of the same database in the same order provides strongly consistent replicates
        \item DBMS does not need to use Two-Phase Commit
    \end{itemize}





















% ==================================================================
% BIBLIOGRAPHY
% ==================================================================
\newpage
\bibliographystyle{abbrvnat}
\bibliography{12-logging}

\end{document}
