\documentclass[11pt]{article}

\newcommand{\lecturenumber}{9}
\newcommand{\lecturename}{OLTP Indexes - Part 2}
\newcommand{\lecturedata}{2018-02-14}

\usepackage{../dbnotes}

\begin{document}

\maketitle
\thispagestyle{plain}

%% ==================================================================
%% INDEX IMPLEMENTATION ISSUES
%% ==================================================================
\section{Index Implementation Issues}
Beyond just what type of data structure one uses for an in-memory database index, there are some 
additional design issues that one must deal with in order to use it in a real DBMS.

%% ----------------------------------------------------
%% Memory Pools
%% ----------------------------------------------------
\subsection*{Memory Pools}
We do not want threads to be calling \texttt{malloc} and \texttt{free} anytime we need to add 
or delete a node in our index.

If all the nodes are the same size (or a small number of fixed sizes), then the index can maintain 
a pool of available nodes. 
\begin{itemize}
    \item \textbf{Insert:}
    Grab a free node, otherwise create a new one.
    
    \item \textbf{Delete:}
    Add the node back to the free pool.
\end{itemize}

We need some policy to decide when to retract the pool size. This is non-trivial.

%% ----------------------------------------------------
%% Garbage Collection
%% ----------------------------------------------------
\subsection*{Garbage Collection}
We need to know when it is safe to reclaim memory for deleted nodes in a latch-free 
index.

\textbf{Approach \#1 -- Reference Counting:}
\begin{itemize}
    \item
    Maintain a counter for each node to keep track of the number of threads that are 
    accessing it.
    \begin{itemize}
        \item Increment the counter before accessing
        \item Decrement it when finished
        \item A node is only safe to delete when the count is zero
    \end{itemize}
    
    \item
    This has bad performance for multi-core CPUs, as changing the counters causes a 
    lot of cache coherence traffic.
\end{itemize}

\textbf{Approach \#2 -- Epoch Garbage Collection:}
\begin{itemize}
    \item
    Maintain a global epoch counter that is periodically updated (e.g., every 10~ms).
    
    \item
    Keep track of what threads enter the index during an epoch and when they leave.
    
    \item
    Mark the current epoch of a node when it is marked for deletion.
    
    \item
    The node can be reclaimed once all threads have left that epoch (and all 
    preceding epochs).
    
    \item
    Also known as Read-Copy-Update (RCU) in Linux.
\end{itemize}

%% ----------------------------------------------------
%% Non-Unique Indexes
%% ----------------------------------------------------
\subsection*{Non-Unique Indexes}
Every index needs to support non-unique indexes~\cite{p203-graefe}.

\textbf{Approach \#1 -- Duplicate Keys:}
\begin{itemize}
    \item
    Use the same node layout as a unique index but store duplicate keys.
\end{itemize}

\textbf{Approach \#2 -- Value Lists:}
\begin{itemize}
    \item
    Store each key only once and maintain a linked list of unique values.
\end{itemize}

%% ----------------------------------------------------
%% Variable Length Keys
%% ----------------------------------------------------
\subsection*{Variable Length Keys}
Not all keys will be the same length.

\textbf{Approach \#1 -- External Pointers:}
\begin{itemize}
    \item
    Store the keys as pointers to the tuples attributes in the table heap.
\end{itemize}

\textbf{Approach \#2 -- Variable Length Nodes:}
\begin{itemize}
    \item
    The size of each node in the index can vary.
    
    \item
    Requires careful memory management.
\end{itemize}

\textbf{Approach \#3 -- Padding:}
\begin{itemize}
    \item
    Always pad the key to the max length of the key type.
    
    \item
    This wastes space and requires that all keys are the same length of the largest possible
    key in the index.
\end{itemize}
    
\textbf{Approach \#4 --Key Map / Indirection:}
\begin{itemize}
    \item
    Embed an array of pointer that map to the key + value list within the node.
    
    \item
    Think of this as the same as a slotted page in a disk-oriented DBMS.
\end{itemize}

%% ----------------------------------------------------
%% Prefix Compression
%% ----------------------------------------------------
\subsection*{Prefix Compression}
Since keys are sorted in lexicographical order, there will be a lot duplicated 
prefixes. 
Store a minimum prefix that is needed to correctly route probes into the index.


%% ==================================================================
%% Adaptive Radix Tree
%% ==================================================================
\section{Adaptive Radix Tree}
The Adaptive Radix Tree (ART) was developed for the HyPer DBMS~\cite{leis-icde2013}.
It uses digital representation of keys to examine prefixes one-by-one instead of comparing entire 
keys. The structure of every radix tree is deterministic (i.e., the layout of nodes will be the 
same regardless of the order that threads insert keys).

The ART index supports four different internal node types with different capacities. It packs in 
multiple digits into a single node to improve cache locality.

\textbf{Key Ideas:}
\begin{itemize}
    \item
    The height of the tree depends on the length of the keys.
    
    \item
    Does not require re-balancing.
    
    \item
    The path to a leaf node represents the key of the leaf.
    
    \item
    Keys are stored implicitly and can be reconstructed from path.
\end{itemize}

%% ----------------------------------------------------
%% Binary Comparable Keys
%% ----------------------------------------------------
\subsection*{Binary Comparable Keys}
Not all attribute types can be decomposed into binary comparable digits for a radix tree. Thus, the 
ART index has to transform the keys into a binary comparable form.

\begin{itemize}
    \item \textbf{Unsigned Integers:}
    Byte order must be flipped for little endian machines.
    
    \item \textbf{Signed Integers:}
    Flip two's complement so that negative numbers are smaller than positive.
    
    \item \textbf{Floats:}
    Classify into group (neg vs. pos, normalized vs denormalized), then store 
    as unsigned integer.
    
    \item \textbf{Compound Keys}:
    Transform each attribute separately and then concatenate them together into a single byte-array.
\end{itemize}

%% ----------------------------------------------------
%% Binary Comparable Keys
%% ----------------------------------------------------
\section{Concurrent ART}
HyPer's ART is \textbf{not} latch free~\cite{leis-damon2016}. There are two ways to make a 
concurrent ART that is thread-safe.

\textbf{Approach \#1 -- Optimistic Lock Coupling (OLC):}
\begin{itemize}
    \item
    Optimistic crabbing scheme where writers are not blocked on readers.
    
    \item
    Writers increment a node's version counter when they acquire latch on that node.
    
    \item
    Readers can proceed if a node's latch is available.
    Before moving to the next node, the reader checks whether the latch's version counter 
    has changed from when it checked the latch.
\end{itemize}
    
\textbf{Approach \#2 -- Read-Optimized Write Exclusion (ROWEX):}
\begin{itemize}
    \item
    Each node includes an exclusive lock that blocks only other writers and not readers.
    
    \item
    Readers proceed without checking versions or locks.
    
    \item
    Every writer must ensure that reads are always consistent.
    
    \item
    Requires fundamental changes to how threads make modifications to index to 
    make the scheme work. The changes will vary per data structure.
\end{itemize}

% \section{Parting Thoughts}
% \begin{itemize}
%     \item Andy was wrong about the Bw-Tree and latch-free indexes
% \end{itemize}



% ==================================================================
% BIBLIOGRAPHY
% ==================================================================
\newpage
\bibliographystyle{abbrvnat}
\bibliography{09-oltpindexes2}














\end{document}
