\documentclass[11pt]{article}

\newcommand{\lecturenumber}{7}
\newcommand{\lecturename}{Index Locking and Latching}
\newcommand{\lecturedata}{2018-02-07}

\usepackage{../dbnotes}

\begin{document}

\maketitle
\thispagestyle{plain}

\section{Database Indexes}
\begin{itemize}
    \item A data structure that improves the speed of data retrieval operations on a table at the cost of additional writes and storage space
    \item Indexes are used to quickly locate data without having to search every row in a table every time a table is accessed
    \item Indexes require different locking because the physical structure can change as long as the logical contents are consistent
\end{itemize}

    \subsection*{Order Perserving Indexes}
    \begin{itemize}
        \item A tree-like structure that maintains keys in some sorted order
        \item Suppports all possible predicates with O(log(n)) searches
    \end{itemize}

\subsection*{Hashing Indexes}
    \begin{itemize}
        \item An associative array that maps a hash of the key to a particular record
        \item Only support equality predicates with O(1) searches
    \end{itemize}

\subsection*{B-tree vs B+Tree}
    \begin{itemize}
        \item The original \textbf{B-Tree} from 1972 stored ll values in all nodes in the tree
        \item B-Tree was more memory efficient since each key only appeares once in the tree
        \item \textbf{B+Tree} only stores values in leaf nodes, and inner nodes only guide the search process
        \item In practice, people use B+Trees over B-Trees because its easier to manage concurrent index access because values are only in the leaf nodes
    \end{itemize}


\subsection*{\textbf{Lock-Free Indexes Approaches}}
    \begin{itemize}
        \item No Locks
        \begin{itemize}
            \item Txns don't acquire locks to access/modify database
            \item Still have to use latches to install updates
        \end{itemize}
        \item No Latches
        \begin{itemize}
            \item Swap pointers using atomic updates to install changes
            \item Still have to use locks to validate txns
        \end{itemize}
    \end{itemize}

\section{Latch Implementations}
\begin{itemize}
    \item Compare and Swap: Atomic instructuion that compares contents of a memory location $M$ to a given value $V$
\end{itemize}
\subsection*{\textbf{Blocking OS Mutex}}
    \begin{itemize}
        \item Simple to use
        \item Non-scalable (about 25ns per lock/unlock invocation)
        \item Example: std::mutex
    \end{itemize}
\subsection*{\textbf{Test-and-Set Spin Lock (TAS)}}
    \begin{itemize}
        \item Very efficient (single instruction to lock/unlock)
        \item Non-scalable, not cache friendly
        \item Example: std::atomic$<$T$>$
    \end{itemize}
\subsection*{\textbf{Queue-Based Spinlock (MCS)}}
    \begin{itemize}
        \item Also known as Mellor-Crummey and Scott (MCS)
        \item More efficient than mutex, better cache locality
        \item Non-trivial memory management
        \item Example: std::atomic$<$Latch*$>$
    \end{itemize}
\subsection*{\textbf{Reader-Writer Locks}}
    \begin{itemize}
        \item Allows for concurrent readers
        \item Have to manage read/write queues to avoid starvation
        \item Can be implemented ontop of spinlocks
    \end{itemize}

\section{Index Latching}
\subsection*{Latch Crabbing}
    \begin{itemize}
        \item Acquire and release latches on B+Tree nodes when traversing the data structure
        \item A thread can release latch on a parent node if tis child node is considered \textbf{safe}
        \begin{itemize}
            \item A node is safe it wont split or merge when updated
            \item Not full (on insertion)
            \item More than half-full (on deletes)
        \end{itemize}
        \item Search: Start at root and go down, repeatedly acquiring read (\lock{R}) latch on child, and next unlocking parent
        \item Insert/Delete: Start at root and go down, acquiring write (\lock{W}) latches if needed. Once child is locked, if it is safe, release all locks on ancestors
        \item Issue: this locks the root as the first step each time, which is a large bottle neck
    \end{itemize}

\subsection*{Better Latch Crabbing~\cite{a1-bayer}}
    \begin{itemize}
        \item Optimistically assume that the leaf is safe
        \begin{itemize}
            \item Take \lock{R} latches as you traverse the tree to reach leaf and verify
            \item If leaf is not safe, fallback to previous algorithm
            \item Also called \textbf{optimistic lock coupling}
        \end{itemize}
    \end{itemize}

\section{Index Locking Schemes}
\begin{itemize}
    \item \textbf{Crabbing does not protect from phantoms because we are releasing locks as soon as insert/delete operation ends}
    \item There needs to be a way to protect the index's logical contents from other txns to avoid phantoms
    \item Difference with index latches
    \begin{itemize}
        \item Locks are held for the entire duration of a txn
        \item Only acquired at the leaf nodes
        \item Not physically stored in index data structure
    \end{itemize}
\end{itemize}
\subsection*{\textbf{Predicate Locks}~\cite{p624-eswaran}}
    \begin{itemize}
        \item Proposed locking scheme from \dbSys{System R}
        \item Shared lock on the predicate in a \sql{WHERE} clause of a \sql{SELECT} query
        \item Exclusive lock on the predicate in a \sql{WHERE} clause of any \sql{UPDATE},\sql{INSERT}, and \sql{DELETE}
        \item Never implemented in any system
        \item Precision locks are a simplification of predicate locks
        \item Can determine if there will be a conflict by looking at the query without having to run it
        \item Not used in practice
    \end{itemize}

\subsection*{\textbf{Key-Value Locks}}
    \begin{itemize}
        \item Locks that cover a single key value
        \item Need "virtual keys" for non-existent values
        \item Can't store lock in index
    \end{itemize}

\subsection*{\textbf{Gap Locks}}
    \begin{itemize}
        \item Each txn acquires a key-value lock on the single key that it wants to access, then get a gap lock on the next key gap
        \item Can't store lock in index
    \end{itemize}

\subsection*{\textbf{Key-Range Locks}}
    \begin{itemize}
        \item A txn takes locks on ranges in the key space
        \item Each range is from one key that appears in the relation, to the next that appears
        \item Define lock modes so conflict table will capture commutativity of the of the operations available
    \end{itemize}
\subsection*{\textbf{Hierarchical Locking}}
    \begin{itemize}
        \item Allow for a txn to hold wider key-range locks with different locking modes
        \item Reduces the number of visits to lock manager
        \item Allows for nesting of compatible locks (e.g. an \lock{X} lock inside an \lock{IX} key-range lock)
    \end{itemize}


% ==================================================================
% BIBLIOGRAPHY
% ==================================================================
\newpage
\bibliographystyle{abbrvnat}
\bibliography{07-indexlocking}





\end{document}
