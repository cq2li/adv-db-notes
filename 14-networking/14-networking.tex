\documentclass[11pt]{article}

\newcommand{\lecturenumber}{14}
\newcommand{\lecturename}{Networking Protocols}
\newcommand{\lecturedata}{2018-03-05}

\usepackage{../dbnotes}

\begin{document}

\maketitle
\thispagestyle{plain}

\section{Database Access}
\begin{itemize}
    \item Real programs access the database through an API
    \begin{enumerate}
        \item Direct Access (DBMS-specific)
        \item Open Database Connectivity (ODBC)
        \item Java Database Connectivity (JDBC)
    \end{enumerate}

    \subsection*{Open Database Connectivity (ODBC)}
    \begin{itemize}
        \item Standard API for accessing a DBMS. Designed to be independent of the DBMS and OS
        \item Originally developed in the early 1990s by Microsoft and Simba Technology
        \item Every major relational DBMS now has an ODBC implementation
        \item ODBC is based on the device driver model
        \item The \textbf{driver} encapsulates the logic needed to convert a standard set of commands into the DBMS-specific calls
        \item Between the ODBC driver and the database is the \textbf{wire protocol}
    \end{itemize}

    \subsection*{Java Database Connectivity (JDBC)}
    \begin{itemize}
        \item Developed by Sun Microsystems in 1997 to provide a standard API for connecting a Java program with a DBMS
        \item JDBC can be considered a version of ODBC for the programming language Java instead of C
        \item Different implementations

        \subsubsection*{JDBC-ODBC Bridge}
        \begin{itemize}
            \item Convert JDBC method calls into ODBC function calls
        \end{itemize}

        \subsubsection*{Native-API Driver}
        \begin{itemize}
            \item Convert JDBC method calls into native calls of the target DBMS API
        \end{itemize}

        \subsubsection*{Network-Protocol Driver}
        \begin{itemize}
            \item Driver connects to a middleware that converts JDBC calls into a vendor-specific DBMS protocol
        \end{itemize}

        \subsubsection*{Database Protocol Driver}
        \begin{itemize}
            \item Pure Java implementation that converts JDBC calls directly into a vendor-specific DBMS protocol
        \end{itemize}
    \end{itemize}

\end{itemize}


\section{Database Networking Protocols}
\begin{itemize}
    \item All major DBMSs implement their own proprietary wire protocol over TCP/IP
    \item ODBC masks the complexity of each individuals DBMSs wire protocol
\end{itemize}

    \subsection*{Typical client/server interaction}
    \begin{itemize}
        \item Client connects to DBMS and begins authentication process. There may be an SSL ahndshake
        \item Client sends a query
        \item DBMS executes the query, then serializes the results and sends it back to the client
    \end{itemize}

    \subsection{Existing Protocols}
    \begin{itemize}
        \item Most newer systems implement one of the open-source DBMS wire protocols. This allows them to reuse the client drivers without having to develop and support them
        \item Just because one DBMS "speaks" another DBMS's wire protocol does not mean that it is compatible
        \begin{itemize}
            \item They also need to support catalogs, SQL dialect, and other functionality
        \end{itemize}
    \end{itemize}


\section{Protocol Design Space ~\cite{p1022-muehleisen}}

    \subsection*{Row vs Column Layout}
    \begin{itemize}
        \item ODBC and JDBC are inherently row-oriented APIs
        \item The DBMS packages tuples into messages one tuple at a time
        \item The client has to deserialize data one tuple at a time
        \item But modern data analysis software operates on matrices and columns
        \item One potential solution is to send data in vectors
    \end{itemize}

    \subsection*{Compression}
    \begin{itemize}
        \item Approaches
        \begin{enumerate}
            \item Naive Compression
            \item Columnar-Specific Encoding
        \end{enumerate}
        \item More heavyweight compression is better when the network is slow
        \item Better compression ratios for larger chunk sizes
        \item Naive compression is probably the better approach
    \end{itemize}


    \subsection*{Data Serialization}
        \subsubsection*{Approach 1: Binary Encoding}
        \begin{itemize}
            \item Have to handle endian conversion on client
            \item The closer the serialized format is tot he DBMS's binary format, then the lower the overhead to serialize
            \item DBMS can implement its own format or rely on existing libraries (ProtoBuf, Thrift)
        \end{itemize}

        \subsubsection*{Approach 2: Binary Encoding}
        \begin{itemize}
            \item Convert all binary values into strings
            \item Do not have to worry about endianness
        \end{itemize}


    \subsection*{String Handling}
        \subsubsection*{Approach 1: Null Termination}
        \begin{itemize}
            \item Store a null byte ('\\0') to denote the end of a string
            \item Client has to scan entire string to find end
        \end{itemize}

        \subsubsection*{Approach 2: Length Prefixes}
        \begin{itemize}
            \item Add the length of the string at the beginning of the bytes
        \end{itemize}

        \subsubsection*{Approach 3: Fixed Width}
        \begin{itemize}
            \item Pad every string to be the max size of the attribute
        \end{itemize}


\section{Kernel Bypass Methods}
\begin{itemize}
    \item The DBMS's network protocol implementation is not the only source of slowdown
    \item The OS's TCP/IP stack is slow due to:
    \begin{itemize}
        \item Expensive context switches and interrupts
        \item Data copying
        \item Lots of latches in the kernel
    \end{itemize}
    \item Allows the system to get data directly from the NIC into the DBMs address space
    \item No unecessary data copying or OS TCP/IP stack

    \subsection*{Data Plan Development Kit}
    \begin{itemize}
        \item Set of libraries that allows programs to access NIC directly
        \item Treat the NIC as a bare metal device
        \item Requires the DBMS code to do more to manage memory and buffers
        \item No data copying or system calls
    \end{itemize}

    \subsection*{Remote Direct Memory Access}
    \begin{itemize}
        \item Read and write memory directly on a remote host without going through the OS
        \item The client needs to know the correct address of the data that it wants to access
        \item The Server is unaware that memory is being accessed remotely
    \end{itemize}



\end{itemize}







% ==================================================================
% BIBLIOGRAPHY
% ==================================================================
\newpage
\bibliographystyle{abbrvnat}
\bibliography{14-networking}

\end{document}
