\documentclass[11pt]{article}

\newcommand{\lecturenumber}{15}
\newcommand{\lecturename}{Optimizer Implementation (Part I)}
\newcommand{\lecturedata}{2018-03-21}

\usepackage{../dbnotes}

\begin{document}

\maketitle
\thispagestyle{plain}

\section{Query Optimization}
\begin{itemize}
    \item For a given query, the goal is to find a \textbf{correct} execution plan that has the lowest \textbf{cost}
    \begin{itemize}
        \item Correct: DBMS produces the answer that the user wants
        \item Cost: The cost is a relative term to choose plans and depends on operating environment
    \end{itemize}
    \item This is the part of a DBMS that is the hardest to implement well (proven to be NP-complete)
    \item No optimizer truly produces the "optimal" plan

    \subsection*{Logical Vs Physical plans}
    \begin{itemize}
        \item The optimizer generates a mapping of a logical algebra expression to the optimal equivalent physical algebra expression
        \item Physical operators define a specific execution strategy using a particular access path
        \item Not always a 1:1 mapping from logical to physical
        \item Transformations between logical and physical plans can depend on the data format
        \item Two relational algebra expressions are said to be \textbf{equivalent} if on every legal database instance the two expressions generate the same tuple result set
    \end{itemize}

    \subsection*{Optimization in OLTP}
    \begin{itemize}
        \item Query planning for OLTP queries is easy because they are \textbf{sargable} (Search Argument Able)
        \item It is usually just picking the best index
        \item Joins are almost always on foreign key relationships with a small cardinality
        \item Can be implemented with simple heuristics
    \end{itemize}

\end{itemize}

\section{Query Optimization Approaches}

    \subsection*{Optimization Granularity}
        \subsubsection*{Choice 1: Single Query}
        \begin{itemize}
            \item Much smaller search space
            \item DBMS cannot reuse results across queries
            \item In order to account for resource contention, the cost model must account for what is currently running
        \end{itemize}

        \subsubsection*{Choice 2: Multiple Queries}
        \begin{itemize}
            \item More efficient if there are many similar queries
            \item Search space is much larger
            \item USeful for scan sharing
        \end{itemize}

    \subsection*{Optimization Timing}

        \subsubsection*{Choice 1: Static Optimization}
        \begin{itemize}
            \item Select the best plan prior to execution
            \item Plan quality is dependent on cost model accuracy
            \item Can amortize over executions with prepared statements
            \item Most popular approach
        \end{itemize}

        \subsubsection*{Choice 2: Dynamic Optimization}
        \begin{itemize}
            \item Select operator plans on-the-fly as the queries execute
            \item Will have to re-optimize for multiple executions
            \item Difficult to implement/debug
        \end{itemize}

        \subsubsection*{Choice 3: Hybrid Optimization}
        \begin{itemize}
            \item Compile using a static algorithm
            \item If the error in estimate > threshold, re-optimize
        \end{itemize}

    \subsection*{Optimizing Prepared Statements}

        \subsubsection*{Choice 1: Re-Optimize}
        \begin{itemize}
            \item Rerun optimizer each time the query is invoked
            \item Tricky to reuse existing plans as starting point
        \end{itemize}

        \subsubsection*{Choice 2: Multiple Plans}
        \begin{itemize}
            \item Generate multiple plans for different values of the parameters (e.g. buckets)
        \end{itemize}

        \subsubsection*{Choice 3: Average Plan}
        \begin{itemize}
            \item Choose the average value for a parameter and use that for all invocations
            \item Most popular approach
        \end{itemize}

    \subsection*{Plan Stability}

        \subsubsection*{Choice 1: Hints}
        \begin{itemize}
            \item Allow the DBA to provide hints to the optimizer
        \end{itemize}

        \subsubsection*{Choice 2: Fixed Optimizer Versions}
        \begin{itemize}
            \item Set the optimizer version number and migrate queries one-by-one to the new optimizer
        \end{itemize}

        \subsubsection*{Choice 3: Backwards-Compatible Plans}
        \begin{itemize}
            \item Save query plan from old version and provide it to the new DBMS
        \end{itemize}



\section{Optimization Search Strategies}

    \subsection*{Heuristic-Based Optimization~\cite{p409-youssefi}}
    \begin{itemize}
        \item Define static rules that transform logical operators to a physical plan
        \begin{itemize}
            \item Perform most restrictive selection early
            \item Perform all selections before joins
            \item Predicate/Limit/Projection pushdowns
            \item Join ordering based on cardinality
        \end{itemize}
        \item Used by original verisons of \dbSys{INGRES} and \dbSys{Oracle} (until the mid 1990s)

        \subsubsection*{Advantages}
        \begin{itemize}
            \item Easy to implement and debug
            \item Works reasonably well and is fast for simple queries
        \end{itemize}

        \subsubsection*{Disadvantages}
        \begin{itemize}
            \item Relies on magic constants that predict the efficacy of a planning decision
            \item Nearly impossible to generate query plans when operators have complex inter-dependencies
        \end{itemize}

    \end{itemize}

    \subsection*{Heuristics + Cost-Based Join Search~\cite{p23-selinger}}
    \begin{itemize}
        \item Use static rules to perform initial optimization
        \item Then use dynamic programming to determine best join order for tables
        \item First cost-based query optimizer
        \item Uses \textbf{bottom-up planning} using a divide-and-conquer search method
        \item Used in \dbSys{System R}, early \dbSys{IBM DB2}, and most open-source DBMSs

        \subsubsection*{System R Optimizer}
        \begin{itemize}
            \item Break query up into blocks and generate the logical operators for each block
            \item For each logical operator, generate a set of physical operators that implement it
            \item Then, iteratively construct a "left-deep" tree that minimizes the estimated amount of work to execute the plan
        \end{itemize}

        \subsection*{Advantages}
        \begin{itemize}
            \item Usually finds a reasonable plan withoiut having to perform an exhaustive search
        \end{itemize}

        \subsection*{Disadvantages}
        \begin{itemize}
            \item All the same problems as the heuristic-only approach
            \item Left-deep join trees are not always optimal
            \item Have to take into consideration the physical properties of data in the cost model (e.g. sort order)
        \end{itemize}






    \end{itemize}

    \subsection*{Randomized Algorithms}
    \begin{itemize}
        \item Perform a random walk over a solution space of all possible (valid) plans for a query
        \item Continue searching until a cost threshold is reached or the optimizer runs for a particular length of time

        \subsubsection*{Simulated Annealing~\cite{p9-ioannidis}}
        \begin{itemize}
            \item Start with a query plan that is generated with the heuristic-only approach
            \item Compute a random permutations of operators (e.g. swap the join order of two tables)
            \item Always accept a change that reduces cost
            \item Only accept a change that increases cost with some probability
            \item Reject any change that violates correctnesss (e.g. sort ordering)
        \end{itemize}

        \subsubsection*{Postgres Optimizer}
        \begin{itemize}
            \item More complicated queries use a \textbf{genetic algorithm} that selects join orderings
            \item At the beginning of each round, generate different variants of the query plan
            \item Select the plans that have the lowest cost and permute them with other plans. Repeat.
            \item The mutator function only generates valid plans
        \end{itemize}

        \subsubsection*{Advantages}
        \begin{itemize}
            \item Jumping around the search space randomly alows the optimizer to get out of local minimums
            \item Low memory overhead (if no history is kept)
        \end{itemize}

        \subsubsection*{Disadvantages}
        \begin{itemize}
            \item Difficult to determine why the DBMS may have chosen a particular plan
            \item Have to do extra work to ensure that query plans are deterministic
            \item Still have to implement correctness rules
        \end{itemize}
    \end{itemize}

    \subsection*{Optimizer Generators}
    \begin{itemize}
        \item Use a rule engine that wllos transformations to modify the query plan operators
        \item The physical properties of data is embedded with the operators themselves
        \item Approaches
        \begin{itemize}
            \item Stratefied Search
            \item Unified Search
        \end{itemize}

    \end{itemize}

    \subsection*{Stratefied Search}
    \begin{itemize}
        \item First rewrite the logical query plan using transformation rules
        \item The engine checks whether the transformation is allowed before it can be applied
        \item Cost is never considered in this step

        \subsubsection*{Starburst Optimizer~\cite{p18-lohman}}
        \begin{itemize}
            \item Better implementation of the \dbSys{System R} optimizer that uses declarative rules
            \item Stage 1 - Query Rewrite: Compute a SQL-block level, relational calculus-like representation of queries
            \item Stage 2 - Plan Optimization: Execute a \dbSys{System R} style dynamic programming phase once query rewrite has completed

        \end{itemize}

        \subsubsection*{Advantages}
        \begin{itemize}
            \item Works well in practice with fast performance
        \end{itemize}

        \subsubsection*{Disadvantages}
        \begin{itemize}
            \item Difficult to assign priorities to transformations
            \item Some transformations are difficult to asses without computing multiple cost estimations
            \item Rules maintenance is a huge pain
        \end{itemize}
    \end{itemize}

    \subsection*{Unified Search}
    \begin{itemize}
        \item Unify the notion of both logical to logical and logical to physical transformations
        \item No need for separate stages because everything is transformations
        \item This approach generates a lot more transformations so it makes heavy use of memoization to reduce redundant work

        \subsubsection*{Volcano Optimizer~\cite{p209-graefe}}
        \begin{itemize}
            \item General purpose cost-based query optimizer, based on equivalence rules on algebra
            \item Easily add new operations and equivalence classes
            \item Treats physical properties of data as first-class entities during planning
            \item \textbf{Top-Down approch} using branch-and-bound search

            \item Advantages
            \begin{itemize}
                \item Use declarative rules to generate transformations
                \item Better extensibility with an efficient search engine
                \item Reduce redudnant estimations using memoization
            \end{itemize}

            \item Disadvantages
            \begin{itemize}
                \item All equivalence classes are completely expanded to generate all possible logical operations before the optimization search
                \item Not easy to modify predicates
            \end{itemize}
        \end{itemize}

        \subsubsection*{Top-Down vs Bottom-Up}
        \begin{itemize}
            \item \textbf{Top down optimization}
            \begin{itemize}
                \item Start with the final outcome that you want, and then work down the tree to find the optimal plan that gets you to that goal
                \item Example: Volcano, Cascades
            \end{itemize}

            \item \textbf{Bottom-Up Optimization}
            \begin{itemize}
                \item Start with nothing and then build up the plan to get to the final outcome that you want
                \item Examples: \dbSys{System R}, Starburst
            \end{itemize}
        \end{itemize}

    \end{itemize}

% ==================================================================
% BIBLIOGRAPHY
% ==================================================================
\newpage
\bibliographystyle{abbrvnat}
\bibliography{15-optimizer1}

\end{document}
