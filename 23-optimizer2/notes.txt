# Optimizer Generators

1. Exodus, Volcano, Cascades

2. Separate the search strategy of an optimizer from the data model. Separate the transformation rules and logical operators from physical rules and physical operators.

%% ==================================================================

# Cascades Optimizer

1. Object-oriented implementation of the Volcano query optimizer
    + Supports expression re-writing through direct mapping instead of an exhaustive search.
    + Cascades only explores a group on demand whereas Volcano exhaustively generates all equivalent logical expressions in a initial phase before starting the optimization search.


%% ==================================================================


# Predicate Push-down Optimization


1. Approach #1: Logical Transformation Rule
    + Predicate push-down is a logical transformation rule like any other in Cascades.
    + This creates an exponential # of equivalent operator trees.
    + Can use the cost-model to determine the benefit of a push-down.
   
2. Approach #2: Rewrite Phase
    + Perform the push-down *before* starting the Cascades search as an initial rewrite phase.
    + More efficient to execute, but is disconnected from the cost model and thus may be tricky to support complex predicate.

3. Approach #3: Late Binding
    + Perform the push-down *after* generating the optimal plan in Cascades.
    + Will likely produce a bad plan because the Cascades search does not consider predicates (i.e., the selectivity of every operation is '1').

4. Peloton Push-down Implementation:
    + First extract the predicates from the query split on conjunctions. 
    + Group them based on what tables they reference. Predicates that reference more than one table are stored in a separate group for that set of tables.
    + The optimizer then needs to figure out where to place these predicates in the query's logical plan.

5. Predicate Migration
    + Not all predicates cost the same to evalaute (e.g., UDFs, string comparisons)
    + If you can compute the cost of evaluating a predicate and its selectivity, you can determine the optimal evaluation order.
    + The generalized approach supports a second pass over the tree to move predicates to their optimal location to minimize an objective function.
    
    
%% ==================================================================

# Nested Queries

1. Five types of nested queries
    + Type-A
    + Type-N
    + Type-J
    + Type-JA
    + Type-D
    
%% ==================================================================

# MemSQL Optimizef

1. This paper does not really follow the standard definitions of the last 30 years of query optimization literature:
    + This makes some things confusing
    + But it also is an example of somebody coming up with potentially new ideas that are not encumbered by how things were done in the past.
    
2. Rewriter: Cost-based Logical->Logical Transformations
    + Paper talks about SQL-to-SQL transformations, but it also says that it is doing operator-to-operator (logical) transformations.
    + 

3. Enumerator: Cost-based Logical->Physical Transformations
  
4. Planner: Physical->SQL Transformation
